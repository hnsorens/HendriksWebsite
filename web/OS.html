<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Hendrik Sorensen - Custom OS Development Documentation">
    <title>Custom OS Documentation | Hendrik Sorensen</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #34495e;
            --accent: #3498db;
            --light: #ecf0f1;
            --dark: #1a252f;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --darker: #0a0a1a;
            --lighter: #f9fafb;
            --card-bg: rgba(30, 41, 59, 0.7);
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            min-height: 100vh;
        }
        
        /* Sidebar Styles */
        .sidebar {
            width: 280px;
            background: var(--primary);
            color: white;
            padding: 20px 0;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .sidebar-header h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            background: linear-gradient(to right, var(--success), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .sidebar ul {
            list-style: none;
        }
        
        .sidebar li {
            position: relative;
        }
        
        .sidebar li a {
            display: block;
            padding: 12px 20px;
            color: var(--light);
            text-decoration: none;
            transition: all 0.3s;
            border-left: 3px solid transparent;
        }
        
        .sidebar li a:hover {
            background: rgba(255,255,255,0.05);
            border-left-color: var(--accent);
        }
        
        .sidebar li a.active {
            background: rgba(255,255,255,0.1);
            border-left-color: var(--accent);
            font-weight: 500;
        }
        
        /* Content Styles */
        .content {
            flex: 1;
            padding: 30px 40px;
            max-width: 1200px;
        }
        
        .content-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .content-header h1 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--success), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .content-header .breadcrumb {
            display: flex;
            gap: 10px;
            color: var(--secondary);
            font-size: 0.9rem;
        }
        
        .content-header .breadcrumb a {
            color: var(--accent);
            text-decoration: none;
        }
        
        section {
            margin-bottom: 40px;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        section h2 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        section h2 i {
            color: var(--accent);
        }
        
        section h3 {
            color: var(--secondary);
            margin: 20px 0 15px;
            font-size: 1.4rem;
        }
        
        section h4 {
            color: var(--secondary);
            margin: 15px 0 10px;
            font-size: 1.2rem;
        }
        
        section p {
            margin-bottom: 15px;
        }
        
        section ul, section ol {
            margin: 15px 0 15px 30px;
        }
        
        section li {
            margin-bottom: 8px;
        }
        
        /* Memory Map Visualization */
        .memory-map {
            width: 100%;
            margin: 20px 0;
            background: var(--light);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }
        
        .memory-segment {
            display: flex;
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }
        
        .memory-segment:hover {
            background: rgba(52, 152, 219, 0.1);
        }
        
        .memory-address {
            width: 200px;
            font-family: 'Fira Code', monospace;
            color: var(--success);
        }
        
        .memory-name {
            flex: 1;
            font-weight: 600;
        }
        
        .memory-description {
            flex: 2;
            color: var(--secondary);
            opacity: 0.8;
        }
        
        .memory-size {
            width: 120px;
            text-align: right;
            color: var(--accent);
            font-family: 'Fira Code', monospace;
        }
        
        /* Code Blocks */
        pre {
            background: #282c34;
            border-radius: 6px;
            padding: 16px;
            margin: 20px 0;
            overflow-x: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        code {
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .hljs {
            background: transparent;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }
            
            .content {
                padding: 20px;
            }
            
            .memory-segment {
                flex-direction: column;
            }
            
            .memory-address, .memory-size {
                width: 100%;
                text-align: left;
            }
            
            .memory-size {
                margin-top: 0.5rem;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        /* Alert Boxes */
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            position: relative;
        }
        
        .alert-note {
            background-color: #e7f5ff;
            border-left: 4px solid var(--accent);
        }
        
        .alert-warning {
            background-color: #fff4e6;
            border-left: 4px solid var(--warning);
        }
        
        .alert-danger {
            background-color: #fff5f5;
            border-left: 4px solid var(--danger);
        }
        
        .alert-success {
            background-color: #ebfbee;
            border-left: 4px solid var(--success);
        }
        
        .alert-title {
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            border-top: 1px solid #eee;
            color: var(--secondary);
            font-size: 0.9em;
        }
        
        /* Animation for sections */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        section {
            animation: fadeIn 0.5s ease-out;
        }

        /* Standard Library Section Styles */
        .stdlib-section {
            margin-bottom: 25px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }

        .stdlib-header {
            background-color: var(--secondary);
            color: rgb(255, 255, 255);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .stdlib-title {
            color: var(--light);
        }

        .stdlib-header:hover {
            background-color: #2c3e50;
            color: white;
        }

        .stdlib-header h3 {
            margin: 0;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stdlib-header i {
            transition: transform 0.2s;
        }

        .stdlib-header.collapsed i {
            transform: rotate(-90deg);
        }

        .stdlib-content {
            padding: 0;
            background-color: white;
            max-height: 10000px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .stdlib-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }

        .function-list {
            padding: 20px;
        }

        .function-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #eee;
        }

        .function-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .function-signature {
            font-family: 'Fira Code', monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow-x: auto;
        }

        .function-signature .return-type {
            color: var(--accent);
        }

        .function-signature .function-name {
            color: var(--primary);
            font-weight: bold;
        }

        .function-signature .parameters {
            color: var(--secondary);
        }

        .function-signature .parameter-type {
            color: var(--success);
        }

        .function-description {
            color: var(--secondary);
            font-size: 0.95em;
            line-height: 1.5;
        }

        .category-header {
            background-color: var(--light);
            padding: 12px 20px;
            margin: 0;
            font-size: 1.1rem;
            color: var(--primary);
            border-bottom: 1px solid #e0e0e0;
        }

        .syscall-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #2a4365;
        }

        .syscall-section h5 {
            color: #63b3ed;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .syscall-list {
            padding-left: 20px;
        }

        .syscall-list li {
            margin-bottom: 8px;
            font-family: monospace;
        }

        .syscall-list strong {
            color: #a0aec0;
            display: inline-block;
            width: 100px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2><i class="fas fa-cog"></i> Custom OS Documentation</h2>
            </div>
            <ul>
                <li><a href="#overview" class="active"><i class="fas fa-info-circle"></i> System Overview</a></li>
                <li><a href="#std" class="active"><i class="fas fa-book"></i> Standard Library</a></li>
                <li><a href="#setup"><i class="fas fa-cogs"></i> Kernel Setup</a></li>
                <li><a href="#core"><i class="fas fa-microchip"></i> Core Systems</a></li>
                <li><a href="#drivers"><i class="fas fa-plug"></i> Device Drivers</a></li>
                <li><a href="#memory"><i class="fas fa-memory"></i> Memory Management</a></li>
                <li><a href="#processes"><i class="fas fa-tasks"></i> Process Management</a></li>
                <li><a href="#filesystem"><i class="fas fa-folder-open"></i> Filesystem</a></li>
                <li><a href="#shell"><i class="fas fa-terminal"></i> Shell</a></li>
            </ul>
        </div>
        <div class="content">
            <div class="content-header">
                <h1>Custom Operating System</h1>
                <div class="breadcrumb">
                    <span><i class="fas fa-home"></i></span>
                    <span><a href="#">Documentation</a></span>
                    <span><i class="fas fa-chevron-right"></i></span>
                    <span>OS Reference</span>
                </div>
            </div>

            <!-- Overview Section -->
            <section id="overview">
                <h2><i class="fas fa-info-circle"></i> System Overview</h2>
                <div class="section-content">
                    <p>This operating system is designed from the ground up for x86-64 architecture, leveraging modern hardware capabilities while maintaining simplicity and performance. The system boots via UEFI and implements all critical operating system components including memory management, process scheduling, device drivers, and filesystems.</p>
                    
                    <div class="alert alert-note">
                        <div class="alert-title"><i class="fas fa-info-circle"></i> Note</div>
                        <p>This documentation assumes familiarity with operating system concepts and x86-64 architecture.</p>
                    </div>

                    <h3>Design Philosophy</h3>
                    <ul>
                        <li><strong>Modularity:</strong> Components are designed to be independent and replaceable</li>
                        <li><strong>Performance:</strong> Optimized for modern hardware with attention to cache efficiency</li>
                        <li><strong>Security:</strong> Memory protection, privilege separation, and careful validation</li>
                        <li><strong>Extensibility:</strong> Designed to accommodate future features and hardware</li>
                    </ul>

                    <h3>Key Features</h3>
                    <ul>
                        <li>UEFI-based bootloader with ELF64 kernel loading</li>
                        <li>Advanced virtual memory system with 4KB and 2MB pages</li>
                        <li>Preemptive multitasking with round robin scheduling</li>
                        <li>Virtual filesystem layer with EXT2 implementation</li>
                        <li>TTY and framebuffer console support</li>
                    </ul>
                </div>
            </section>

            <!-- Standard Library Section -->
<section id="std">
    <h2><i class="fas fa-book"></i> Standard Library</h2>
    <div class="section-content">
        <p>The custom standard library provides implementations of common C standard library functions along with additional utilities specific to the operating system environment.</p>
        
        <h3>Existing C Standard Implementations</h3>
        
        <!-- ctype.c -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> ctype</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <pre><code class="language-c">/**
 * @brief Check if character is alphanumeric
 * @param c Character to check
 * @return Non-zero if alphanumeric, zero otherwise
 */
int isalnum(int c);

/**
 * @brief Check if character is alphabetic
 * @param c Character to check
 * @return Non-zero if alphabetic, zero otherwise
 */
int isalpha(int c);

/**
 * @brief Check if character is a control character
 * @param c Character to check
 * @return Non-zero if control character, zero otherwise
 */
int iscntrl(int c);

/**
 * @brief Check if character is a decimal digit
 * @param c Character to check
 * @return Non-zero if decimal digit, zero otherwise
 */
int isdigit(int c);

/**
 * @brief Check if character is lowercase
 * @param c Character to check
 * @return Non-zero if lowercase, zero otherwise
 */
int islower(int c);

/**
 * @brief Check if character has graphical representation
 * @param c Character to check
 * @return Non-zero if graphical, zero otherwise
 */
int isgraph(int c);

/**
 * @brief Check if character is printable
 * @param c Character to check
 * @return Non-zero if printable, zero otherwise
 */
int isprint(int c);

/**
 * @brief Check if character is punctuation
 * @param c Character to check
 * @return Non-zero if punctuation, zero otherwise
 */
int ispunct(int c);

/**
 * @brief Check if character is whitespace
 * @param c Character to check
 * @return Non-zero if whitespace, zero otherwise
 */
int isspace(int c);

/**
 * @brief Check if character is uppercase
 * @param c Character to check
 * @return Non-zero if uppercase, zero otherwise
 */
int isupper(int c);

/**
 * @brief Check if character is hexadecimal digit
 * @param c Character to check
 * @return Non-zero if hexadecimal digit, zero otherwise
 */
int isxdigit(int c);

/**
 * @brief Check if character is blank (space or tab)
 * @param c Character to check
 * @return Non-zero if blank, zero otherwise
 */
int isblank(int c);

/* Case conversion functions */

/**
 * @brief Convert character to lowercase
 * @param c Character to convert
 * @return Lowercase equivalent if uppercase, otherwise unchanged
 */
int tolower(int c);

/**
 * @brief Convert character to uppercase
 * @param c Character to convert
 * @return Uppercase equivalent if lowercase, otherwise unchanged
 */
int toupper(int c);
                </code></pre>
            </div>
        </div>

        <!-- stdio.h -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> stdio</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <pre><code class="language-c">/**
 * @brief Open a file
 * @param filename Path to the file to open
 * @param mode Opening mode ("r", "w", "a", etc.)
 * @return FILE pointer on success, NULL on failure
 */
FILE* fopen(const char* filename, const char* mode);

/**
 * @brief Close a file
 * @param stream FILE pointer to close
 * @return 0 on success, EOF on failure
 */
int fclose(FILE* stream);

/**
 * @brief Read data from a file
 * @param ptr Pointer to buffer where data will be stored
 * @param size Size of each element to read
 * @param nmemb Number of elements to read
 * @param stream FILE pointer to read from
 * @return Number of elements successfully read
 */
size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);

/**
 * @brief Write data to a file
 * @param ptr Pointer to data to write
 * @param size Size of each element to write
 * @param nmemb Number of elements to write
 * @param stream FILE pointer to write to
 * @return Number of elements successfully written
 */
size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream);

/**
 * @brief Reposition file position indicator
 * @param stream FILE pointer to seek on
 * @param offset Number of bytes to offset
 * @param whence Position from which offset is measured (SEEK_SET, SEEK_CUR, SEEK_END)
 * @return 0 on success, non-zero on failure
 */
int fseek(FILE* stream, long offset, int whence);

/**
 * @brief Get current file position
 * @param stream FILE pointer to examine
 * @return Current file position, or -1 on error
 * @note Currently unimplemented, always returns 0
 */
long ftell(FILE* stream);

/**
 * @brief Reset file position to beginning
 * @param stream FILE pointer to rewind
 */
void rewind(FILE* stream);

/**
 * @brief Print formatted output to a file
 * @param stream FILE pointer to write to
 * @param format Format string
 * @return Number of characters written, or negative on error
 * @note Currently unimplemented, always returns 0
 */
int fprintf(FILE* stream, const char* format, ...);

/**
 * @brief Print formatted output to stdout
 * @param format Format string
 * @return Number of characters written
 */
int printf(const char* format, ...);

/**
 * @brief Read formatted input from stdin
 * @param format Format string
 * @return Number of input items successfully matched and assigned
 */
int scanf(const char* format, ...);

/**
 * @brief Read a character from a file
 * @param stream FILE pointer to read from
 * @return Character read as unsigned char cast to int, or EOF on error
 * @note Currently unimplemented, always returns EOF
 */
int fgetc(FILE* stream);

/**
 * @brief Read a character from a file (macro version of fgetc)
 * @param stream FILE pointer to read from
 * @return Character read as unsigned char cast to int, or EOF on error
 */
int getc(FILE* stream);

/**
 * @brief Read a character from stdin
 * @return Character read as unsigned char cast to int, or EOF on error
 */
int getchar(void);

/**
 * @brief Write a character to a file
 * @param c Character to write
 * @param stream FILE pointer to write to
 * @return Character written as unsigned char cast to int, or EOF on error
 * @note Currently unimplemented, always returns EOF
 */
int fputc(int c, FILE* stream);

/**
 * @brief Write a character to a file (macro version of fputc)
 * @param c Character to write
 * @param stream FILE pointer to write to
 * @return Character written as unsigned char cast to int, or EOF on error
 */
int putc(int c, FILE* stream);

/**
 * @brief Write a character to stdout
 * @param c Character to write
 * @return Character written as unsigned char cast to int, or EOF on error
 */
int putchar(int c);

/**
 * @brief Read a line from a file
 * @param s Buffer to store the read line
 * @param size Maximum number of characters to read
 * @param stream FILE pointer to read from
 * @return s on success, NULL on error or when no characters are read
 */
char* fgets(char* s, int size, FILE* stream);

/**
 * @brief Initialize standard streams
 * @note Internal initialization function
 */
void __stdio_init(void);
                </code></pre>
            </div>
        </div>

        <!-- stdlib.h -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> stdlib</h3>
                <i class="fas fa-chevron-down"></i>
            </div>

            <div class="stdlib-content">
                <pre><code class="language-c">/**
 * @brief Terminate the program with the specified status code
 * @param __status The exit status code (0 for success, non-zero for error)
 */
void exit(int __status);

/**
 * @brief Convert a string to an integer
 * @param __nptr The string to convert
 * @return The converted integer value
 */
int atoi(const char* __nptr);

/**
 * @brief Allocate memory block
 * @param __size Size of the memory block to allocate (in bytes)
 * @return Pointer to allocated memory block, or NULL if allocation fails
 */
void* malloc(size_t __size);

/**
 * @brief Reallocate memory block
 * @param __ptr Pointer to previously allocated memory block
 * @param __size New size for the memory block (in bytes)
 * @return Pointer to reallocated memory block, or NULL if reallocation fails
 * @note If __ptr is NULL, behaves like malloc(). If __size is 0, behaves like free().
 */
void* realloc(void* __ptr, size_t __size);

/**
 * @brief Allocate and zero-initialize memory block
 * @param __nmemb Number of elements to allocate
 * @param __size Size of each element (in bytes)
 * @return Pointer to allocated memory block, or NULL if allocation fails
 * @note The allocated memory is initialized to zero
 */
void* calloc(size_t __nmemb, size_t __size);

/**
 * @brief Free allocated memory block
 * @param __ptr Pointer to memory block to free
 * @note If __ptr is NULL, no operation is performed
 */
void free(void* __ptr);
                </</code></pre>
            </div>
        </div>

        <!-- string.h -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> string</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <pre><code class="language-c">/**
 * @brief Calculate the length of a string
 * @param __s The string to measure
 * @return The length of the string in bytes
 */
size_t strlen(const char* __s);

/**
 * @brief Copy a string
 * @param __dest Destination buffer
 * @param __src Source string
 * @return Pointer to destination buffer
 */
char* strcpy(char* __restrict __dest, const char* __restrict __src);

/**
 * @brief Copy up to n characters from a string
 * @param __dest Destination buffer
 * @param __src Source string
 * @param __n Maximum number of characters to copy
 * @return Pointer to destination buffer
 * @note If src is shorter than n, the remainder is filled with null bytes
 */
char* strncpy(char* __restrict __dest, const char* __restrict __src, size_t __n);

/**
 * @brief Compare two strings
 * @param __s1 First string to compare
 * @param __s2 Second string to compare
 * @return Negative if s1 < s2, zero if equal, positive if s1 > s2
 */
int strcmp(const char* __s1, const char* __s2);

/**
 * @brief Compare first n characters of two strings
 * @param __s1 First string to compare
 * @param __s2 Second string to compare
 * @param __n Maximum number of characters to compare
 * @return Negative if s1 < s2, zero if equal, positive if s1 > s2
 */
int strncmp(const char* __s1, const char* __s2, size_t __n);

/**
 * @brief Concatenate two strings
 * @param __dest Destination buffer (must have enough space)
 * @param __src Source string to append
 * @return Pointer to destination buffer
 */
char* strcat(char* __restrict __dest, const char* __restrict __src);

/**
 * @brief Concatenate up to n characters from a string
 * @param __dest Destination buffer
 * @param __src Source string to append
 * @param __n Maximum number of characters to append
 * @return Pointer to destination buffer
 */
char* strncat(char* __restrict __dest, const char* __restrict __src, size_t __n);

/**
 * @brief Locate first occurrence of character in string
 * @param __s String to search
 * @param __c Character to locate
 * @return Pointer to first occurrence, or NULL if not found
 */
char* strchr(const char* __s, int __c);

/**
 * @brief Locate last occurrence of character in string
 * @param __s String to search
 * @param __c Character to locate
 * @return Pointer to last occurrence, or NULL if not found
 */
char* strrchr(const char* __s, int __c);

/**
 * @brief Locate substring
 * @param __haystack String to search
 * @param __needle Substring to find
 * @return Pointer to beginning of substring, or NULL if not found
 */
char* strstr(const char* __haystack, const char* __needle);

/**
 * @brief Copy memory area
 * @param __dest Destination buffer
 * @param __src Source buffer
 * @param __n Number of bytes to copy
 * @return Pointer to destination buffer
 * @note The memory areas must not overlap (use memmove if they do)
 */
void* memcpy(void* __restrict __dest, const void* __restrict __src, size_t __n);

/**
 * @brief Fill memory with a constant byte
 * @param __s Memory area to fill
 * @param __c Value to set (converted to unsigned char)
 * @param __n Number of bytes to fill
 * @return Pointer to the memory area
 */
void* memset(void* __s, int __c, size_t __n);

/**
 * @brief Compare memory areas
 * @param __s1 First memory area
 * @param __s2 Second memory area
 * @param __n Number of bytes to compare
 * @return Negative if s1 < s2, zero if equal, positive if s1 > s2
 */
int memcmp(const void* __s1, const void* __s2, size_t __n);

/**
 * @brief Copy memory area (handles overlapping regions)
 * @param __dest Destination buffer
 * @param __src Source buffer
 * @param __n Number of bytes to copy
 * @return Pointer to destination buffer
 */
void* memmove(void* __dest, const void* __src, size_t __n);

/**
 * @brief Scan memory for a character
 * @param __s Memory area to scan
 * @param __c Character to locate (converted to unsigned char)
 * @param __n Number of bytes to scan
 * @return Pointer to matching byte, or NULL if not found
 */
void* memchr(const void* __s, int __c, size_t __n);

/**
 * @brief Get length of initial segment consisting entirely of characters in accept
 * @param __s String to analyze
 * @param __accept Set of characters to accept
 * @return Length of initial segment containing only characters from accept
 */
size_t strspn(const char* __s, const char* __accept);

/**
 * @brief Get length of initial segment not containing reject characters
 * @param __s String to analyze
 * @param __reject Set of characters to reject
 * @return Length of initial segment without any characters from reject
 */
size_t strcspn(const char* __s, const char* __reject);

/**
 * @brief Locate first occurrence in string of any character from accept
 * @param __s String to search
 * @param __accept Set of characters to search for
 * @return Pointer to first matching character, or NULL if none found
 */
char* strpbrk(const char* __s, const char* __accept);
                </code></pre>
            </div>
        </div>

        <!-- unistd.h -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> unistd</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <pre><code class="language-c">/**
 * @brief Duplicate a file descriptor
 * @param __fd Old file descriptor
 * @param __fd2 New file descriptor (if already open, it's closed first)
 * @return New file descriptor on success, -1 on error
 */
int dup2(int __fd, int __fd2);

/**
 * @brief Read from a file descriptor
 * @param __fd File descriptor to read from
 * @param __buf Buffer to store read data
 * @param __nbytes Maximum number of bytes to read
 * @return Number of bytes read, 0 on EOF, -1 on error
 * @note Currently unimplemented, always returns 0
 */
ssize_t read(int __fd, void* __buf, size_t __nbytes);

/**
 * @brief Write to a file descriptor
 * @param __fd File descriptor to write to
 * @param __buf Buffer containing data to write
 * @param __n Number of bytes to write
 * @return Number of bytes written, -1 on error
 * @note Currently unimplemented, always returns 0
 */
ssize_t write(int __fd, const void* __buf, size_t __n);

/**
 * @brief Close a file descriptor
 * @param __fd File descriptor to close
 * @return 0 on success, -1 on error
 * @note Currently unimplemented, always returns 0
 */
int close(int __fd);

/**
 * @brief Create a new process
 * @return 0 to child process, child PID to parent, -1 on error
 */
pid_t fork(void);

/**
 * @brief Get process ID
 * @return Process ID of calling process
 * @note Currently unimplemented
 */
pid_t getpid(void);

/**
 * @brief Set process group ID
 * @param __pid Process ID (0 means calling process)
 * @param __pgid Process group ID (0 means use PID)
 * @return 0 on success, -1 on error
 */
int setpgid(pid_t __pid, pid_t __pgid);

/**
 * @brief Get session ID
 * @param __pid Process ID (0 means calling process)
 * @return Session ID on success, -1 on error
 */
pid_t getsid(pid_t __pid);

/**
 * @brief Execute program
 * @param __path Path to executable
 * @param __argv Argument vector (NULL-terminated)
 * @param __envp Environment vector (NULL-terminated)
 * @return Does not return on success, -1 on error
 */
int execve(const char* __path, char* const __argv[], char* const __envp[]);

/**
 * @brief Suspend execution for interval
 * @param __seconds Number of seconds to sleep
 * @return 0 on success, unslept seconds if interrupted
 * @note Currently unimplemented, always returns 0
 */
unsigned int sleep(unsigned int __seconds);

/**
 * @brief Create pipe
 * @param __pipedes Array to store read (0) and write (1) file descriptors
 * @return 0 on success, -1 on error
 * @note Currently unimplemented, always returns 0
 */
int pipe(int __pipedes[2]);

/**
 * @brief Set terminal foreground process group
 * @param __fd Terminal file descriptor
 * @param __pgrp_id Process group ID
 * @return 0 on success, -1 on error
 */
int tcsetpgrp(int __fd, pid_t __pgrp_id);

/**
 * @brief Get terminal foreground process group
 * @param __fd Terminal file descriptor
 * @return Process group ID on success, -1 on error
 */
pid_t tcgetpgrp(int __fd);

/**
 * @brief Get current working directory
 * @param __buf Buffer to store path (NULL to let system allocate)
 * @param __size Size of buffer
 * @return Pointer to buffer containing path, NULL on error
 */
char* getcwd(char* __buf, size_t __size);

/**
 * @brief Change working directory
 * @param __path Path to new working directory
 * @return 0 on success, -1 on error
 */
int chdir(const char* __path);
                </code></pre>
            </div>
        </div>

        <!-- wait.h -->
        <div class="stdlib-section">
            <div class="stdlib-header">
                <h3 class="stdlib-title"><i class="fas fa-file-code"></i> wait</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <div class="function-list">
                    <pre><code class="language-c">/**
 * @brief Wait for process state changes
 * @param pid  >0: specific child, -1: any child, 0: group, <-1: group -pid
 * @param stat_loc Pointer to store status (use W* macros to examine)
 * @param options WNOHANG|WUNTRACED|WCONTINUED
 * @return PID of changed child, 0 (WNOHANG), or -1 on error
 */
pid_t waitpid(pid_t pid, int* stat_loc, int options);
                    </code></pre>
                </div>
            </div>
        </div>
        
        <!-- <h3>Custom OS-specific Functions</h3> -->
        
        <!-- <div class="stdlib-section">
            <div class="stdlib-header">
                <h3><i class="fas fa-file-code"></i> oslib.h</h3>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="stdlib-content">
                <div class="function-list">
                    <div class="function-item">
                        <div class="function-signature">
                            <span class="return-type">int</span> 
                            <span class="function-name">os_get_system_info</span>(
                            <span class="parameters"><span class="parameter-type">struct system_info *</span>info</span>)
                        </div>
                        <div class="function-description">
                            Retrieves system information including memory size, kernel version, and uptime.
                            Returns 0 on success, -1 on error.
                        </div>
                    </div>
                    
                    <div class="function-item">
                        <div class="function-signature">
                            <span class="return-type">int</span> 
                            <span class="function-name">os_create_window</span>(
                            <span class="parameters"><span class="parameter-type">int</span> width, <span class="parameter-type">int</span> height, <span class="parameter-type">const char *</span>title</span>)
                        </div>
                        <div class="function-description">
                            Creates a new graphical window. Returns window ID on success, -1 on error.
                        </div>
                    </div>
                </div>
            </div>
        </div> -->
    </div>
</section>

            <!-- Kernel Setup Section -->
            <section id="setup">
                <h2><i class="fas fa-cogs"></i> Kernel Setup</h2>
                <div class="section-content">
                    <h3>UEFI Bootloader</h3>
                    <p>The system begins execution in UEFI firmware environment which loads the operating system. The bootloader performs the following tasks:</p>
                    <ul>
                        <li>Initializes basic graphics mode (GOP) for early display output</li>
                        <li>Sets up memory map and reserves necessary regions</li>
                        <li>Loads the 64-bit kernel ELF binary into memory</li>
                        <li>Prepares system tables (ACPI, SMBIOS) for kernel use</li>
                        <li>Transitions to 64-bit long mode before jumping to kernel</li>
                    </ul>
                    
                    <h3>Boot Services</h3>
                    <p>When UEFI Loads the operating system, various UEFI boot services are provided. Before doing anything with paging, the OS must exit the boot services, which disable all UEFI tools. Before doing so, the OS performs the following tasks:</p>
                    <ul>
                        <li><strong>Initializes Framebuffer:</strong> The framebuffer address and information is stored, so the framebuffer can be used at a later time.</li>
                        <li><strong>Loads default system font:</strong> A system font is conveniently loaded before the filesystem is initialized.</li>
                        <li><strong>Collects the UEFI memory map:</strong> The UEFI memory map is collected which includes the operating system's code, so the kernel knows which memory to reserve initially.</li>
                    </ul>
                    
                    <pre><code class="language-c">/* Initializes EFI Services */
InitializeLib(ImageHandle, SystemTable);

/* =============== COLLECT SYSTEM INFORMATION =============== */
if (EFI_ERROR(init_framebuffer(&preboot_info, ImageHandle, SystemTable)))
{
    Print(L"Framebuffer Initialization Failed!\n");
    return EFI_LOAD_ERROR;
}

/* Load terminal font before exiting boot services */
init_terminal_font(&TEMPFONT, L"UbuntuMono-Regular.ttf", 20, ImageHandle);

/* Step 2: Exit UEFI environment */
if (EFI_ERROR(exit_boot_services(&amppreboot_info, ImageHandle, SystemTable)))
{
    Print(L"Failed to exit boot services!\n");
    return EFI_LOAD_ERROR;
}                   </code></pre>
                    <p>The code above is the at the begging of main.</p>
                    
                    <h3>Early Memory Management</h3>
                    <p>When the boot services first exit, all the kernel knows about memory is the size and the reserved pages. In the early memory stages, there is no memory allocator or page allocator, so the memory map has to be manually parsed to find places that are free. This step initially sets up memory for the page allocator, kernel stack, and more.</p>
                    <ul>
                        <li><strong>Kernel Stack:</strong> An initial stack is allocated so the kernel doesn't have to use the UEFI allocated stack anymore</li>
                        <li><strong>Page Allocation Table:</strong> The page allocation table is used for storing allocation statuses of pages</li>
                        <li><strong>Page Table:</strong> Memory for the kernel page table is allocated</li>
                        <li><strong>Global Variables:</strong> Global variables are all allocated instead of defined, since the kernel code is moved to a higher address after setup</li>
                    </ul>
                </div>
            </section>

            <!-- Core Systems Section -->
            <section id="core">
                <h2><i class="fas fa-microchip"></i> Core Systems</h2>
                <div class="section-content">
                    <h3>Global Descriptor Table (GDT) Implementation</h3>
                    <p>
                        The GDT is a fundamental x86-64 data structure that defines memory segments and their attributes. 
                        This implementation handles both segment descriptors and the Task State Segment (TSS) for privilege 
                        level transitions and interrupt handling.
                    </p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li><strong>Complete GDT Setup</strong> - Initializes 7 entries including null, kernel/user segments, and TSS</li>
                        <li><strong>64-bit TSS Support</strong> - Implements the x86-64 Task State Segment structure with interrupt stacks</li>
                        <li><strong>Ring 0 & Ring 3 Segments</strong> - Separate code/data segments for kernel and user modes</li>
                        <li><strong>Low-level Assembly Integration</strong> - Uses inline assembly for LGDT, segment register updates, and far jumps</li>
                    </ul>
                    
                    <h4>Implementation Details:</h4>
                    <ul>
                        <li>Uses packed structures to match x86 memory layout requirements exactly</li>
                        <li>Sets up kernel stack pointer (RSP0) for privilege level transitions</li>
                        <li>Implements proper descriptor flags for 64-bit mode operation</li>
                        <li>Handles the 2-slot TSS descriptor requirement for 64-bit systems</li>
                    </ul>
                    
                    <h4>Technical Highlights:</h4>
                    <p>
                        The GDT initialization carefully constructs each descriptor with proper access flags (0x9A for kernel code, 
                        0x92 for kernel data, 0xFA for user code, and 0xF2 for user data). The TSS setup includes space for 
                        7 interrupt stack table entries (IST1-7) which are crucial for handling exceptions and interrupts 
                        with separate stacks.
                    </p>
                    
                    <p>
                        The assembly sequence after loading the GDT performs a far jump to reload CS with the new code segment 
                        descriptor and updates all data segment registers to point to the kernel data segment.
                    </p>

                    
                    <h3>Interrupt Descriptor Table (IDT) Implementation</h3>
                    <p>
                        The IDT is a critical x86-64 structure that defines the processor's response to interrupts and exceptions.
                        This comprehensive implementation handles hardware interrupts, CPU exceptions, and system calls with robust
                        error recovery and signal delivery to user processes.
                    </p>
                    
                    <h4>Key Features:</h4>
                    <ul>
                        <li><strong>Complete Interrupt Handling</strong> - Supports all 256 interrupt vectors including CPU exceptions and hardware IRQs</li>
                        <li><strong>Signal Delivery System</strong> - Maps exceptions to POSIX-style signals (SIGSEGV, SIGILL, etc.) for user processes</li>
                        <li><strong>Dual-stack Architecture</strong> - Uses separate stacks for interrupts and exceptions via TSS IST mechanism</li>
                        <li><strong>Hardware Abstraction</strong> - Integrates with PIC (8259A) for legacy interrupt handling</li>
                    </ul>
                    
                    <h4>Technical Implementation:</h4>
                    <ul>
                        <li>Structured IDT entries with proper privilege separation (Ring 0-3)</li>
                        <li>Exception-specific handling with detailed error code analysis</li>
                        <li>Page fault handler with Copy-on-Write (COW) support</li>
                        <li>Context-aware interrupt processing with process scheduling integration</li>
                        <li>Low-level assembly integration for register preservation and control transfer</li>
                    </ul>
                    
                    <h4>Notable Components:</h4>
                    <div class="code-highlight">
                        <ul>
                            <li><strong>idt_set_descriptor()</strong> - Configures interrupt gates with flexible privilege levels</li>
                            <li><strong>exception_handler()</strong> - Detailed CPU exception processing with 20+ specific cases</li>
                            <li><strong>interrupt_handler()</strong> - Hardware interrupt dispatcher (timer, keyboard, mouse)</li>
                            <li><strong>check_signal()</strong> - POSIX-compatible signal delivery mechanism</li>
                        </ul>
                    </div>
                    
                    <h4>Advanced Features:</h4>
                    <p>
                        The implementation includes sophisticated error handling like page fault analysis with CR2 register inspection,
                        general protection fault error code decoding, and proper signal delivery for user-space processes. The timer
                        interrupt handler integrates directly with the process scheduler for preemptive multitasking.
                    </p>
                    
                    <p>
                        Special attention was given to security considerations, including proper privilege level separation
                        (especially for system calls at vector 0x80) and interrupt stack isolation to prevent stack overflow
                        scenarios during nested interrupts.
                    </p>
                    
                    <h3>x86-64 Interrupt Service Routines (Assembly Implementation)</h3>
                    <p>
                        This low-level assembly implementation provides the foundation for the operating system's interrupt handling,
                        featuring optimized context switching, robust error handling, and system call support. The code directly
                        interfaces with CPU hardware features while maintaining compatibility with the C-based kernel architecture.
                    </p>
                    
                    <h4>Core Features:</h4>
                    <ul>
                        <li><strong>Complete ISR Stubs</strong> - Handlers for all 256 interrupt vectors (0-255) including CPU exceptions and hardware IRQs</li>
                        <li><strong>Dual Macro System</strong> - <code>isr_no_err</code> and <code>isr_err</code> macros automate proper error code handling</li>
                        <li><strong>Full Context Preservation</strong> - Saves/restores all 16 general-purpose registers (RAX-R15) plus CR3</li>
                        <li><strong>Kernel Stack Switching</strong> - Automatic transition to dedicated kernel stack during interrupts</li>
                        <li><strong>System Call Gateway</strong> - Specialized handler for syscall dispatch via system call table</li>
                    </ul>
                    
                    <h4>Technical Highlights:</h4>
                    <div class="code-features">
                        <ul>
                            <li><strong>Register Preservation</strong> - Meticulous push/pop sequence maintains execution context</li>
                            <li><strong>Error Code Handling</strong> - Special handling for exceptions that push error codes (e.g., Page Fault, GPF)</li>
                            <li><strong>PIC EOI Signaling</strong> - Proper End-of-Interrupt notification to Programmable Interrupt Controller</li>
                            <li><strong>CR3 Management</strong> - Page table base register preservation for process isolation</li>
                            <li><strong>Signal Integration</strong> - Calls <code>check_signal</code> after each interrupt for POSIX signal delivery</li>
                        </ul>
                    </div>
                    
                    <h4>Key Components:</h4>
                    <div class="component-grid">
                        <div class="component">
                            <h4>Exception Handlers (0-31)</h4>
                            <ul>
                                <li>Divide-by-zero (#DE)</li>
                                <li>Page Fault (#PF)</li>
                                <li>General Protection Fault (#GP)</li>
                                <li>Double Fault (#DF)</li>
                                <li>All x86-64 defined exceptions</li>
                            </ul>
                        </div>
                        <div class="component">
                            <h4>Hardware IRQs (32-47)</h4>
                            <ul>
                                <li>Timer interrupt (IRQ0)</li>
                                <li>Keyboard (IRQ1)</li>
                                <li>Cascade (IRQ2)</li>
                                <li>All legacy PIC interrupts</li>
                            </ul>
                        </div>
                        <div class="component">
                            <h4>Special Handlers</h4>
                            <ul>
                                <li>System call gateway (0x80)</li>
                                <li>Generated stubs for unused vectors</li>
                                <li>GDT reload functionality</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h4>Optimization Techniques:</h4>
                    <p>
                        The implementation uses NASM macros to eliminate code duplication, generating 256 optimized ISR stubs with only
                        2 macro definitions. The system call handler features direct dispatch to kernel functions via a system call table,
                        while maintaining full register state across the privilege boundary.
                    </p>
                    
                    <p>
                        Special care was taken to handle the x86-64 interrupt stack frame requirements, including proper alignment
                        and the use of <code>iretq</code> for 64-bit interrupt returns. The design supports nested interrupts while
                        preventing stack overflow through dedicated interrupt stacks.
                    </p>
                    <h3>System Call Interface</h3>

<p>
    A low-level x86-64 syscall implementation providing POSIX-compatible system services
    through hardware-accelerated SYSCALL/SYSRET instructions with full process isolation.
</p>

<h4>Core Architecture</h4>
<ul>
    <li><strong>Hardware Acceleration</strong>
        <ul>
            <li>SYSCALL/SYSRET instruction support</li>
            <li>MSR-configured privilege transition</li>
            <li>Automatic interrupt masking during execution</li>
        </ul>
    </li>
    
    <li><strong>Process Isolation</strong>
        <ul>
            <li>User-space argument handling via process stack</li>
            <li>Per-process context preservation</li>
            <li>Signal-based security enforcement</li>
        </ul>
    </li>
    
    <li><strong>System Call Table</strong>
        <ul>
            <li>21 POSIX-compatible system calls</li>
            <li>Default handler for unused syscalls (SIGSYS)</li>
            <li>Macro-based registration (syscall_def)</li>
        </ul>
    </li>
</ul>

<h4>Key System Calls</h4>

<div class="syscall-section">
    <h5>Process Management</h5>
    <ul class="syscall-list">
        <li><strong>exit</strong> (1): Terminate calling process with exit code</li>
        <li><strong>fork</strong> (8): Create duplicate process context</li>
        <li><strong>execve</strong> (2): Execute program with argument vector</li>
        <li><strong>waitpid</strong> (17): Wait for process termination</li>
        <li><strong>kill</strong> (20): Send signal to process/group</li>
    </ul>
</div>

<div class="syscall-section">
    <h5>File Operations</h5>
    <ul class="syscall-list">
        <li><strong>open</strong> (12): Open file and return descriptor</li>
        <li><strong>close</strong> (14): Close file descriptor</li>
        <li><strong>dup2</strong> (13): Duplicate file descriptor</li>
        <li><strong>seek</strong> (21): Reposition file offset</li>
        <li><strong>write</strong> (4): Write to file descriptor</li>
        <li><strong>input</strong> (3): Read from file descriptor</li>
    </ul>
</div>

<div class="syscall-section">
    <h5>Memory Management</h5>
    <ul class="syscall-list">
        <li><strong>mmap</strong> (7): Map memory to process space (anonymous only)</li>
    </ul>
</div>

<div class="syscall-section">
    <h5>Process Groups</h5>
    <ul class="syscall-list">
        <li><strong>setpgid</strong> (11): Set process group ID</li>
        <li><strong>getpgid</strong> (10): Get process group ID</li>
        <li><strong>setsid</strong> (18): Create new session</li>
        <li><strong>getsid</strong> (19): Get session ID</li>
        <li><strong>tcsetpgrp</strong> (15): Set terminal foreground group</li>
        <li><strong>tcgetpgrp</strong> (16): Get terminal foreground group</li>
    </ul>
</div>

<div class="syscall-section">
    <h5>Filesystem Navigation</h5>
    <ul class="syscall-list">
        <li><strong>chdir</strong> (5): Change working directory</li>
        <li><strong>getcwd</strong> (6): Get current working directory</li>
    </ul>
</div>

<h4>Technical Implementation</h4>
<ul>
    <li><strong>MSR Configuration</strong>
        <ul>
            <li>IA32_STAR (0xC0000081): Sets CS segments for privilege transition</li>
            <li>IA32_LSTAR (0xC0000082): Syscall entry point (syscall_stub)</li>
            <li>IA32_FMASK (0xC0000084): Masks RFLAGS during syscalls</li>
        </ul>
    </li>
    
    <li><strong>Argument Handling</strong>
        <ul>
            <li>Six-parameter support via registers:
                <ul>
                    <li>ARG1: RDI</li>
                    <li>ARG2: RSI</li>
                    <li>ARG3: RDX</li>
                    <li>ARG4: R10</li>
                    <li>ARG5: R8</li>
                    <li>ARG6: R9</li>
                </ul>
            </li>
            <li>SYS_ARG_1 to SYS_ARG_6 macros for access</li>
        </ul>
    </li>
    
    <li><strong>Security Model</strong>
        <ul>
            <li>SIGSYS for invalid syscalls</li>
            <li>SIGTTOU/SIGTTIN for terminal access violations</li>
            <li>Process group verification for I/O operations</li>
        </ul>
    </li>
</ul>
                </div>
            </section>

            <!-- Drivers Section -->
            <section id="drivers">
                <h2><i class="fas fa-plug"></i> Device Drivers</h2>
                <div class="section-content">
                    <h3>Framebuffer Console (fbcon)</h3>
                    <p>The framebuffer console provides high-performance text output with advanced features:</p>
                    <ul>
                        <li>Supports multiple fonts loaded from PSF format</li>
                        <li>Hardware-accelerated scrolling and blitting</li>
                        <li>Multiple color schemes and customizable palettes</li>
                        <li>Backbuffer for flicker-free updates</li>
                        <li>Cursor rendering with customizable styles</li>
                    </ul>
                    
                    <h3>Virtual Console (vcon)</h3>
                    <p>The TTY driver provides traditional terminal functionality:</p>
                    <ul>
                        <li>Line discipline for canonical mode processing</li>
                        <li>VT100-compatible escape sequence handling</li>
                        <li>Multiple virtual terminals with hotkey switching</li>
                        <li>Input/output queues with flow control</li>
                        <li>Session and process group management</li>
                    </ul>
                    
                    <h3>PS/2 Keyboard Driver Implementation</h3>
                    <p>
                        A complete keyboard driver with scancode translation, modifier handling,
                        and event queuing for a custom operating system.
                    </p>
                    
                    <h4>Key Features</h4>
                    <ul>
                        <li><strong>Scancode Translation</strong>
                            <ul>
                                <li>Handles standard PS/2 scancode set 1</li>
                                <li>Supports extended keys (0xE0 prefix)</li>
                                <li>Separate mappings for shifted/unshifted keys</li>
                            </ul>
                        </li>
                        
                        <li><strong>Modifier Handling</strong>
                            <ul>
                                <li>Tracks Ctrl, Shift, Alt, AltGr states</li>
                                <li>Manages toggle keys (Caps Lock, Num Lock, Scroll Lock)</li>
                                <li>Automatic case conversion with Caps Lock</li>
                            </ul>
                        </li>
                        
                        <li><strong>Event System</strong>
                            <ul>
                                <li>Circular buffer for key events</li>
                                <li>Press/release detection</li>
                                <li>Event queue with overflow protection</li>
                            </ul>
                        </li>
                        
                        <li><strong>Hardware Interface</strong>
                            <ul>
                                <li>PS/2 controller communication</li>
                                <li>Interrupt-driven operation (IRQ1)</li>
                                <li>Proper EOI handling</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Technical Details</h4>
                    <ul>
                        <li>Supports all standard alphanumeric keys</li>
                        <li>Handles function keys F1-F12</li>
                        <li>Processes navigation keys (arrows, home, end, etc.)</li>
                        <li>Supports keypad keys with Num Lock</li>
                        <li>Implements special keys (Print Screen, Pause, etc.)</li>
                    </ul>
                    
                    <h4>Implementation Notes</h4>
                    <ul>
                        <li>Uses a state machine for extended key sequences</li>
                        <li>Maintains separate keycode and scancode representations</li>
                        <li>Provides device file interface for user-space access</li>
                        <li>Includes proper initialization sequence for PS/2 controller</li>
                    </ul>
                </div>
            </section>

            <!-- Memory Management Section -->
            <section id="memory">
                <h2><i class="fas fa-memory"></i> Memory Management</h2>
                <div class="section-content">
                    <h3>Kernel Virtual Memory Map</h3>
                    <p>The kernel maintains this virtual address space layout:</p>
                    
                    <div class="memory-segment">
                        <div class="memory-address">0x0000000000000000 - 0x00007FFFFFFFFFFF</div>
                        <div class="memory-name">User Space</div>
                        <div class="memory-description">Per-process address space for applications</div>
                        <div class="memory-size">128TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFF800000000000 - 0xFFFFFFFFFFFFFFFF</div>
                        <div class="memory-name">Kernel Space</div>
                        <div class="memory-description">Higher-half kernel mappings, identical across all address spaces</div>
                        <div class="memory-size">128TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF800000000000 - 0xFFFF80FFFFFFFFFF</div>
                        <div class="memory-name">Kernel Code/Data</div>
                        <div class="memory-description">Direct mapping of kernel ELF sections with appropriate permissions</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF810000000000 - 0xFFFF81FFFFFFFFFF</div>
                        <div class="memory-name">Kernel Stack</div>
                        <div class="memory-description">Kernel's Interrupt Stack, every Interrupt is sent to the beginning</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF820000000000 - 0xFFFF82FFFFFFFFFF</div>
                        <div class="memory-name">Kernel Heap</div>
                        <div class="memory-description">Kernel's Heap used for dynamic allocation</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF830000000000 - 0xFFFF83FFFFFFFFFF</div>
                        <div class="memory-name">Page Allocation Table</div>
                        <div class="memory-description">Memory Used for Memory Page Tracking</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF840000000000 - 0xFFFF84FFFFFFFFFF</div>
                        <div class="memory-name">Kernel Shared Page Table</div>
                        <div class="memory-description">The shared page table kernel entries are used commonly in every page table</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF860000000000 - 0xFFFF86FFFFFFFFFF</div>
                        <div class="memory-name">Global Variables</div>
                        <div class="memory-description">Memory for Global Variables (backwards allocation see below)</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF870000000000 - 0xFFFF87FFFFFFFFFF</div>
                        <div class="memory-name">Frame Buffer</div>
                        <div class="memory-description">Space for Frame Buffer</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <div class="memory-segment">
                        <div class="memory-address">0xFFFF890000000000 - 0xFFFFFFFFFFFFFFFF</div>
                        <div class="memory-name">Memory Pools</div>
                        <div class="memory-description">Kernel Memory Reserved For Memory Pools (see below)</div>
                        <div class="memory-size">1TB</div>
                    </div>
                    <h3>Global Variables Manager</h3>
                    <p>
                        A custom-designed global variables allocation system that provides safe, predictable access to kernel globals
                        regardless of virtual memory movements, avoiding traditional pitfalls of global variables in kernel space.
                    </p>

                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Safe Global Access</strong>
                            <ul>
                                <li>Fixed relative addressing prevents virtual memory relocation issues</li>
                                <li>Deterministic memory layout for all global variables</li>
                                <li>No dependency on runtime memory addresses</li>
                            </ul>
                        </li>
                        
                        <li><strong>Reverse Allocation Strategy</strong>
                            <ul>
                                <li>Variables allocated from high memory downward</li>
                                <li>Automatic size calculation through macros</li>
                                <li>Single contiguous block for all globals</li>
                            </ul>
                        </li>
                        
                        <li><strong>Comprehensive Coverage</strong>
                            <ul>
                                <li>Memory management structures</li>
                                <li>Process management variables</li>
                                <li>Graphics system state</li>
                                <li>Filesystem objects</li>
                                <li>Hardware state tracking</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Key Advantages</h4>
                    <ul>
                        <li><strong>Virtual Memory Safety</strong>
                            <ul>
                                <li>Traditional globals become unsafe when kernel code moves in virtual memory</li>
                                <li>This system maintains correct references regardless of virtual address changes</li>
                                <li>Essential for features like higher-half kernels and address space randomization</li>
                            </ul>
                        </li>
                        
                        <li><strong>Deterministic Layout</strong>
                            <ul>
                                <li>Explicit control over variable placement</li>
                                <li>No compiler-dependent ordering</li>
                                <li>Precise knowledge of memory consumption</li>
                            </ul>
                        </li>
                        
                        <li><strong>Single Source of Truth</strong>
                            <ul>
                                <li>All global declarations centralized in one header</li>
                                <li>Clear documentation of each variable's purpose</li>
                                <li>Easy to track dependencies between globals</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Uses macro-based offset calculation:
                            <ul>
                                <li><code>createGlobal(type, last_global)</code> for single variables</li>
                                <li><code>createGlobalArray(type, count, last_global)</code> for arrays</li>
                            </ul>
                        </li>
                        <li>Fixed end address (<code>GLOBAL_VARS_END</code>) serves as allocation anchor</li>
                        <li>Variables declared in reverse order of allocation</li>
                        <li>Automatic size tracking through chained references</li>
                    </ul>

                    <h4>Memory Organization</h4>
                    <ul>
                        <li>Structured into logical sections:
                            <ul>
                                <li>Memory management (bitmaps, page tables, pools)</li>
                                <li>Process management (PID tracking, hash tables)</li>
                                <li>Graphics system (framebuffer, layers)</li>
                                <li>Filesystem (VFS, device nodes)</li>
                                <li>Hardware state (keyboard, mouse)</li>
                            </ul>
                        </li>
                        <li>Total size automatically calculated via <code>GLOBALS_SIZE</code></li>
                        <li>Alignment handled naturally through type sizes</li>
                    </ul>

                    <h4>Design Rationale</h4>
                    <ul>
                        <li>Solves the kernel relocation problem for global variables</li>
                        <li>Provides better organization than scattered extern declarations</li>
                        <li>Enables precise control over kernel memory layout</li>
                        <li>Facilitates debugging through centralized variable tracking</li>
                    </ul>
                    <h3>Virtual Memory Manager</h3> 
                    <p>
                        A complete implementation of x86-64 4-level paging with support for 4KB, 2MB, and 1GB pages,
                        including advanced features like copy-on-write and page table forking.
                    </p>
                    
                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Full 4-Level Paging Support</strong>
                            <ul>
                                <li>PML4 (Page Map Level 4)</li>
                                <li>PDPT (Page Directory Pointer Table)</li>
                                <li>PD (Page Directory)</li>
                                <li>PT (Page Table)</li>
                            </ul>
                        </li>
                        
                        <li><strong>Multiple Page Sizes</strong>
                            <ul>
                                <li>4KB standard pages</li>
                                <li>2MB large pages</li>
                                <li>1GB huge pages</li>
                            </ul>
                        </li>
                        
                        <li><strong>Advanced Memory Management</strong>
                            <ul>
                                <li>Copy-on-Write (COW) support</li>
                                <li>Page table forking</li>
                                <li>Kernel memory mapping</li>
                                <li>TLB management</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Key Functions</h4>
                    <ul>
                        <li><strong>pageTable_addPage</strong> - Maps physical pages into virtual address space</li>
                        <li><strong>pageTable_addKernel</strong> - Maps kernel memory regions</li>
                        <li><strong>pageTable_set</strong> - Activates page tables via CR3</li>
                        <li><strong>pageTable_fork</strong> - Creates copy-on-write page table copies</li>
                        <li><strong>pageTable_find_entry</strong> - Looks up page table entries</li>
                    </ul>
                    
                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Uses canonical 48-bit virtual addresses</li>
                        <li>Implements proper flag handling (Present, Writable, User, etc.)</li>
                        <li>Handles all x86-64 paging structure levels</li>
                        <li>Includes TLB invalidation when modifying page tables</li>
                        <li>Maintains consistency between different page sizes</li>
                    </ul>
                    
                    <h4>Optimizations</h4>
                    <ul>
                        <li>Large page support reduces TLB pressure</li>
                        <li>Copy-on-Write minimizes memory duplication</li>
                        <li>Recursive table copying for efficient forks</li>
                        <li>Careful CR3 management during operations</li>
                    </ul>
                    
                    <h3>Physical Memory Manager</h3>
                    
                    <p>
                        A comprehensive physical page allocator supporting both 4KB and 2MB pages,
                        with bitmap tracking and stack-based free page management.
                    </p>
                    
                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Dual-Page Size Support</strong>
                            <ul>
                                <li>4KB page allocations</li>
                                <li>2MB large page allocations</li>
                                <li>Automatic consistency between page sizes</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Tracking</strong>
                            <ul>
                                <li>Bitmap-based allocation tracking</li>
                                <li>Stack-based free page management</li>
                                <li>Memory reservation capability</li>
                            </ul>
                        </li>
                        
                        <li><strong>Management Functions</strong>
                            <ul>
                                <li>pages_initAllocTable - Initialize memory tracking structures</li>
                                <li>pages_allocatePage - Allocate physical pages</li>
                                <li>pages_free - Release allocated pages</li>
                                <li>pages_reservePage - Mark pages as reserved</li>
                                <li>pages_generateFreeStack - Rebuild free page lists</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Uses two separate bitmaps for 4KB and 2MB pages</li>
                        <li>Maintains consistency between page sizes:
                            <ul>
                                <li>Allocating a 2MB page marks all 512 constituent 4KB pages</li>
                                <li>Freeing a 2MB page clears all 512 constituent 4KB pages</li>
                            </ul>
                        </li>
                        <li>Free stacks provide O(1) allocation/free operations</li>
                        <li>Defensive checks against double-free and invalid operations</li>
                    </ul>
                    
                    <h4>Memory Layout</h4>
                    <ul>
                        <li>Single contiguous allocation table contains:
                            <ul>
                                <li>2MB page bitmap</li>
                                <li>4KB page bitmap</li>
                                <li>2MB free page stack</li>
                                <li>4KB free page stack</li>
                            </ul>
                        </li>
                        <li>Bitmaps use 1 bit per page</li>
                        <li>Free stacks contain page indices</li>
                    </ul>
                
    
                    <h3>Kernel Heap Implementation</h3>
                    
                    <p>
                        A complete heap for the kernel, featuring allocation, deallocation,
                        and memory operations with both basic and optimized implementations.
                    </p>
                    
                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Heap Management</strong>
                            <ul>
                                <li>Block-based allocation with free list</li>
                                <li>8-byte aligned allocations</li>
                                <li>Block splitting for efficient memory use</li>
                                <li>Coalescing of adjacent free blocks</li>
                            </ul>
                        </li>
                        
                        <li><strong>Allocation Functions</strong>
                            <ul>
                                <li>kmalloc - Basic memory allocation</li>
                                <li>kaligned_alloc - Alignment-aware allocation</li>
                                <li>krealloc - Memory block resizing</li>
                                <li>kfree - Memory deallocation</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Technical Details</h4>
                    <ul>
                        <li>Uses block headers for metadata (size + next pointer)</li>
                        <li>Free list management with O(n) allocation time</li>
                        <li>Handles arbitrary alignment requirements</li>
                        <li>Includes special cases for NULL/zero-size operations</li>
                        <li>Provides both simple and optimized implementations</li>
                    </ul>
                    
                    <h4>Optimizations</h4>
                    <ul>
                        <li>Automatic block splitting to reduce fragmentation</li>
                        <li>Alignment handling without wasted space</li>
                        <li>Fallback to byte-by-byte operations when needed</li>
                    </ul>

                    <h3>Kernel Memory Pool Allocator</h3>
                    
                    <p>
                        A high-performance fixed-size object allocator designed for kernel use,
                        featuring demand-paged backing storage and efficient object reuse.
                    </p>
                    
                    <h4>Key Features</h4>
                    <ul>
                        <li><strong>Fixed-Size Allocation</strong>
                            <ul>
                                <li>Optimized for same-sized object allocation</li>
                                <li>Guaranteed alignment of all objects</li>
                                <li>Efficient reuse of freed objects</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Management</strong>
                            <ul>
                                <li>1TB virtual address space per pool</li>
                                <li>On-demand physical page allocation</li>
                                <li>Automatic page mapping when needed</li>
                                <li>LIFO free list for fast allocations</li>
                            </ul>
                        </li>
                        
                        <li><strong>Core Functions</strong>
                            <ul>
                                <li>pool_create - Initialize new memory pool</li>
                                <li>pool_allocate - Allocate object from pool</li>
                                <li>pool_free - Return object to pool</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Uses separate allocation and free paths:
                            <ul>
                                <li>Sequential allocation for new objects</li>
                                <li>Free stack for recycled objects</li>
                            </ul>
                        </li>
                        <li>Handles page boundary crossings automatically</li>
                        <li>Tracks pool metadata at base of virtual space</li>
                        <li>Allocates free stack pages on demand</li>
                    </ul>
                    
                    <h4>Performance Characteristics</h4>
                    <ul>
                        <li>O(1) allocation from free list</li>
                        <li>O(1) freeing of objects</li>
                        <li>Minimal fragmentation for fixed-size objects</li>
                        <li>Low memory overhead (only requires alignment padding)</li>
                    </ul>
                    
                </div>
            </section>

            <!-- Process Management Section -->
            <section id="processes">
                <h2><i class="fas fa-tasks"></i> Process Management</h2>
                <div class="section-content">
                    <h3>Process Management</h3>
                    <p>
                        Comprehensive process control implementation handling process creation, memory management,
                        signal delivery, and process group/session management.
                    </p>

                    <h4>Core Structures</h4>
                    <ul>
                        <li><strong>process_t</strong>
                            <ul>
                                <li>Complete process control block (PCB)</li>
                                <li>Contains saved registers, memory maps, file descriptors</li>
                                <li>Maintains process relationships (parent/child, groups)</li>
                            </ul>
                        </li>
                        
                        <li><strong>process_stack_layout_t</strong>
                            <ul>
                                <li>Saved register state for context switching</li>
                                <li>Matches hardware interrupt stack frame</li>
                            </ul>
                        </li>
                        
                        <li><strong>process_group_t / process_session_t</strong>
                            <ul>
                                <li>Collections of related processes</li>
                                <li>Used for terminal control and signal delivery</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Key Functionality</h4>
                    <ul>
                        <li><strong>Process Lifecycle</strong>
                            <ul>
                                <li>process_fork: Creates child process with COW memory</li>
                                <li>process_execvp: Replaces process with new program</li>
                                <li>process_exit: Terminates process and cleans up resources</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Management</strong>
                            <ul>
                                <li>process_add_page: Maps physical memory into process space</li>
                                <li>vmm_fork: Implements copy-on-write page tables</li>
                                <li>Heap and shared memory region management</li>
                            </ul>
                        </li>
                        
                        <li><strong>Signal Handling</strong>
                            <ul>
                                <li>process_signal: Delivers signals to individual processes</li>
                                <li>process_group_signal: Broadcasts signals to groups</li>
                                <li>Special handling for SIGKILL, SIGSTOP, etc.</li>
                            </ul>
                        </li>
                        
                        <li><strong>Process Groups/Sessions</strong>
                            <ul>
                                <li>Hierarchical process organization</li>
                                <li>Terminal control via foreground/background groups</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Implementation Details</h4>
                    <ul>
                        <li><strong>Context Switching</strong>
                            <ul>
                                <li>CR3 register updates for address space switching</li>
                                <li>TSS stack pointer management</li>
                                <li>Register state preservation/restoration</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Regions</strong>
                            <ul>
                                <li>Heap grows upward from 1GB</li>
                                <li>Shared memory grows downward from 128GB</li>
                                <li>Stack fixed at 0x600000-0x7FFFFF (2MB)</li>
                            </ul>
                        </li>
                        
                        <li><strong>Signal Delivery</strong>
                            <ul>
                                <li>SIGKILL forces immediate termination</li>
                                <li>SIGCONT/SIGSTOP manage blocking state</li>
                                <li>Pending signals stored in process control block</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Process States</h4>
                    <ul>
                        <li><strong>Running</strong>: Currently executing on CPU</li>
                        <li><strong>Blocked</strong>: Waiting for event (PROCESS_BLOCKING)</li>
                        <li><strong>Zombie</strong>: Terminated but not reaped (PROCESS_ZOMBIE)</li>
                    </ul>

                    <h4>PID Management</h4>
                    <ul>
                        <li>64-bit process IDs</li>
                        <li>Global counter with no recycling</li>
                        <li>Hash table for PID lookup</li>
                    </ul>
                    
                    <h3>Process Scheduler</h3>
                    <p>
                        A round-robin process scheduler with blocking support, implementing circular queue
                        management and context switching for kernel processes.
                    </p>

                    <h4>Core Functions</h4>
                    <ul>
                        <li><strong>scheduler_nextProcess</strong>
                            <ul>
                                <li>Finds next runnable process in circular queue</li>
                                <li>Skips blocked processes (PROCESS_BLOCKING flag)</li>
                                <li>Updates global PROCESSES pointer</li>
                            </ul>
                        </li>
                        
                        <li><strong>scheduler_schedule</strong>
                            <ul>
                                <li>Adds process to scheduler queue</li>
                                <li>Handles first process case (self-referential)</li>
                                <li>Inserts new processes after current</li>
                                <li>Updates PID hash table</li>
                            </ul>
                        </li>
                        
                        <li><strong>schedule_end</strong>
                            <ul>
                                <li>Removes process from scheduler queue</li>
                                <li>Handles last process case (queue cleanup)</li>
                                <li>Maintains neighbor process links</li>
                            </ul>
                        </li>
                        
                        <li><strong>scheduler_currentProcess</strong>
                            <ul>
                                <li>Returns currently executing process</li>
                                <li>Direct access to global PROCESSES pointer</li>
                            </ul>
                        </li>
                        
                        <li><strong>schedule_block/schedule_unblock</strong>
                            <ul>
                                <li>Sets/clears PROCESS_BLOCKING flag</li>
                                <li>Controls process eligibility for scheduling</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Implementation Details</h4>
                    <ul>
                        <li><strong>Data Structures</strong>
                            <ul>
                                <li>Circular doubly-linked process queue</li>
                                <li>Global PROCESSES pointer tracks current</li>
                                <li>PID hash table for process lookup</li>
                            </ul>
                        </li>
                        
                        <li><strong>Scheduling Algorithm</strong>
                            <ul>
                                <li>Round-robin with blocking support</li>
                                <li>Processes skipped when blocked</li>
                                <li>Queue remains circular after removals</li>
                            </ul>
                        </li>
                        
                        <li><strong>Edge Cases</strong>
                            <ul>
                                <li>Empty queue handling</li>
                                <li>Single process case</li>
                                <li>Removal of current process</li>
                            </ul>
                        </li>
                    </ul>
                    <h3>PID Hash Table</h3>
                    <p>
                        A memory-efficient hash table implementation for fast process ID (PID) to process structure mapping,
                        featuring custom page-based node allocation and O(1) average case operations.
                    </p>

                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Fixed-Size Hash Table</strong>
                            <ul>
                                <li>1024 buckets (2^10)</li>
                                <li>Chaining collision resolution</li>
                                <li>Simple bitmask hash function</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Management</strong>
                            <ul>
                                <li>Page-based node allocation (4KB pages)</li>
                                <li>Freelist for recycled nodes</li>
                                <li>Virtual memory reservation</li>
                            </ul>
                        </li>
                        
                        <li><strong>Basic Operations</strong>
                            <ul>
                                <li>Insert: O(1) average case</li>
                                <li>Lookup: O(1) average case</li>
                                <li>Delete: O(1) average case</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Key Structures</h4>
                    <ul>
                        <li><strong>pid_hash_table_t</strong>
                            <ul>
                                <li>Array of 1024 bucket pointers</li>
                                <li>Freelist for node reuse</li>
                                <li>Memory management tracking</li>
                            </ul>
                        </li>
                        
                        <li><strong>pid_hash_node_t</strong>
                            <ul>
                                <li>Contains PID key and process pointer</li>
                                <li>Next pointer for chaining</li>
                                <li>32-byte structure (on 64-bit systems)</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Implementation Details</h4>
                    <ul>
                        <li><strong>Hashing</strong>
                            <ul>
                                <li>Simple bitmask: pid & (PID_HASH_SIZE - 1)</li>
                                <li>Assumes random PID distribution</li>
                            </ul>
                        </li>
                        
                        <li><strong>Memory Allocation</strong>
                            <ul>
                                <li>Nodes allocated in 4KB pages (≈128 nodes/page)</li>
                                <li>Pages mapped to reserved virtual address space</li>
                                <li>Freelist tracks available nodes</li>
                            </ul>
                        </li>
                        
                        <li><strong>Operation Flow</strong>
                            <ul>
                                <li>Insert: Hash PID → check duplicates → allocate node → add to chain</li>
                                <li>Lookup: Hash PID → search bucket chain</li>
                                <li>Delete: Hash PID → find node → remove from chain → add to freelist</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Performance Characteristics</h4>
                    <ul>
                        <li>Average case O(1) for all operations</li>
                        <li>Worst case O(n) with many hash collisions</li>
                        <li>Memory overhead: ~8 bytes per node (next pointer)</li>
                        <li>No dynamic resizing - fixed 1024 buckets</li>
                    </ul>
                </div>
            </section>

            <!-- Filesystem Section -->
            <section id="filesystem">
                <h2><i class="fas fa-folder-open"></i> Filesystem</h2>
                <div class="section-content">
                    <h3>Virtual File System (VFS)</h3>
                    <p>
                        A unified filesystem abstraction layer providing path resolution,
                        directory management, and filesystem-agnostic file operations.
                    </p>

                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Unified Filesystem Interface</strong>
                            <ul>
                                <li>Supports multiple filesystem types</li>
                                <li>Common operations table for all files</li>
                                <li>Path resolution independent of underlying FS</li>
                            </ul>
                        </li>
                        
                        <li><strong>Hierarchical Structure</strong>
                            <ul>
                                <li>Tree-based directory organization</li>
                                <li>Lazy-loaded directory contents</li>
                                <li>Special directory handling (., ..)</li>
                            </ul>
                        </li>
                        
                        <li><strong>Storage Integration</strong>
                            <ul>
                                <li>GPT partition table parsing</li>
                                <li>IDE disk driver support</li>
                                <li>EXT2 filesystem integration</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Key Structures</h4>
                    <ul>
                        <li><strong>vfs_entry_t</strong>
                            <ul>
                                <li>Inode pointer and metadata</li>
                                <li>Parent/child relationships</li>
                                <li>Filesystem operations table</li>
                                <li>Name hashing for fast lookup</li>
                            </ul>
                        </li>
                        
                        <li><strong>list_head_t</strong>
                            <ul>
                                <li>Doubly-linked list for siblings</li>
                                <li>Circular list for children</li>
                                <li>Container_of macro for type safety</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Core Functions</h4>
                    <ul>
                        <li>vfs_init - Initializes VFS and mounts root filesystem</li>
                        <li>vfs_find_entry - Resolves paths to VFS entries</li>
                        <li>vfs_open_file - Creates file descriptors</li>
                        <li>vfs_create_entry - Creates new filesystem objects</li>
                        <li>vfs_populate_directory - Lazy-loads directory contents</li>
                    </ul>

                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Path resolution:
                            <ul>
                                <li>Handles absolute and relative paths</li>
                                <li>Tokenizes path components</li>
                                <li>Special handling for . and ..</li>
                            </ul>
                        </li>
                        
                        <li>Memory management:
                            <ul>
                                <li>Kernel pools for VFS entries and inodes</li>
                                <li>FNV-1a hashing for efficient lookups</li>
                                <li>On-demand allocation of child entries</li>
                            </ul>
                        </li>
                        
                        <li>Filesystem operations:
                            <ul>
                                <li>Uniform read/write interface</li>
                                <li>Type-specific operations (regfile vs dir)</li>
                                <li>Block device abstraction layer</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Initialization Process</h4>
                    <ul>
                        <li>GPT partition table parsing
                            <ul>
                                <li>Reads partition headers from disk</li>
                                <li>Identifies filesystem partitions</li>
                            </ul>
                        </li>
                        
                        <li>EXT2 filesystem mounting
                            <ul>
                                <li>Initializes superblock and group descriptors</li>
                                <li>Locates root inode (inode 2)</li>
                            </ul>
                        </li>
                        
                        <li>VFS tree construction
                            <ul>
                                <li>Creates root directory entry</li>
                                <li>Pre-creates /dev directory</li>
                                <li>Sets up initial operations tables</li>
                            </ul>
                        </li>
                    </ul>

                    <h3>File Descriptor Manager</h3>
                    <p>
                        A hierarchical file descriptor system supporting 1024 descriptors per process,
                        with sparse allocation, reference counting, and automatic cleanup.
                    </p>

                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Two-Level Descriptor Tables</strong>
                            <ul>
                                <li>32 top-level entries with 32 descriptors each</li>
                                <li>On-demand allocation of descriptor blocks</li>
                                <li>Total capacity of 1024 descriptors per process</li>
                            </ul>
                        </li>
                        
                        <li><strong>File Instance Tracking</strong>
                            <ul>
                                <li>Current file position (offset) per descriptor</li>
                                <li>Reference counting for shared descriptors</li>
                                <li>Filesystem-specific operations table</li>
                            </ul>
                        </li>
                        
                        <li><strong>Management Functions</strong>
                            <ul>
                                <li>fdm_open_file - Creates and initializes file instances</li>
                                <li>fdm_set/fdm_get - Manages descriptor allocation/lookup</li>
                                <li>fdm_copy - Duplicates tables during process fork</li>
                                <li>fdm_free - Releases all resources on process exit</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>Memory-efficient sparse allocation:
                            <ul>
                                <li>Only allocates descriptor blocks when needed</li>
                                <li>Uses kernel memory pools for allocations</li>
                                <li>Null-checking on all operations</li>
                            </ul>
                        </li>
                        
                        <li>Descriptor table operations:
                            <ul>
                                <li>Index calculation via division/modulus (32x32)</li>
                                <li>Automatic block allocation on first use</li>
                                <li>Bounds checking for all descriptor accesses</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Process Integration</h4>
                    <ul>
                        <li>Per-process isolation:
                            <ul>
                                <li>Independent descriptor tables per process</li>
                                <li>Copy-on-fork semantics</li>
                                <li>Automatic cleanup during process termination</li>
                            </ul>
                        </li>
                        
                        <li>Filesystem interaction:
                            <ul>
                                <li>Uniform VFS interface for all filesystems</li>
                                <li>Support for filesystem-private data</li>
                                <li>Direct inode references for fast access</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h3>EXT2 Filesystem Implementation</h3>
                    <p>
                        A functional implementation of core EXT2 filesystem operations with support for basic file and directory management.
                    </p>
                    
                    <h4>Implemented Features</h4>
                    <ul>
                        <li><strong>Filesystem Initialization</strong>
                            <ul>
                                <li>Superblock reading and validation</li>
                                <li>Block group descriptor handling</li>
                                <li>Inode table access</li>
                            </ul>
                        </li>
                        
                        <li><strong>File Operations</strong>
                            <ul>
                                <li>File creation and deletion</li>
                                <li>Reading and writing file data</li>
                                <li>File seeking and truncation</li>
                                <li>Inode metadata management</li>
                            </ul>
                        </li>
                        
                        <li><strong>Directory Operations</strong>
                            <ul>
                                <li>Directory creation and deletion</li>
                                <li>Directory entry management</li>
                                <li>Directory iteration</li>
                                <li>Entry lookup by name</li>
                            </ul>
                        </li>
                        
                        <li><strong>Block Management</strong>
                            <ul>
                                <li>Block allocation and freeing</li>
                                <li>Direct block pointers</li>
                                <li>Single indirect block pointers</li>
                                <li>Block bitmap handling</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h4>Key Technical Details</h4>
                    <ul>
                        <li>Inode structure with 12 direct blocks and 1 indirect block</li>
                        <li>Directory entries with variable-length names</li>
                        <li>Block group allocation strategy</li>
                        <li>Basic permission and file type handling</li>
                        <li>Filesystem metadata updates (timestamps, counters)</li>
                    </ul>
                    
                    <h4>Implementation Notes</h4>
                    <p>The code includes:</p>
                    <ul>
                        <li>Complete inode operations (read/write/update)</li>
                        <li>Directory entry packing/unpacking</li>
                        <li>Block allocation with bitmap tracking</li>
                        <li>Error handling for filesystem operations</li>
                        <li>Basic filesystem consistency checks</li>
                    </ul>
                    <h3>Boot-Time Font Loader</h3>
                    <p>
                        A UEFI-based font loading system that initializes bitmap fonts during boot services,
                        generating texture atlases for kernel text rendering before exiting UEFI environment.
                    </p>

                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>Pre-Exit Boot Initialization</strong>
                            <ul>
                                <li>Operates within UEFI boot environment</li>
                                <li>Loads fonts directly from boot partition</li>
                                <li>Prepares fonts before kernel memory management</li>
                            </ul>
                        </li>
                        
                        <li><strong>Atlas Generation</strong>
                            <ul>
                                <li>512×512 monochrome texture atlas</li>
                                <li>96 ASCII characters (32-127)</li>
                                <li>Per-character metrics storage</li>
                            </ul>
                        </li>
                        
                        <li><strong>UEFI Integration</strong>
                            <ul>
                                <li>Uses EFI protocols for filesystem access</li>
                                <li>Handles partition scanning</li>
                                <li>Direct file reading from boot devices</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Key Structures</h4>
                    <ul>
                        <li><strong>font_t</strong>
                            <ul>
                                <li>atlas: 512×512 pixel bitmap</li>
                                <li>cdata: Glyph metrics array</li>
                                <li>width/height: Character dimensions</li>
                            </ul>
                        </li>
                        
                        <li><strong>stbtt_bakedchar_t</strong>
                            <ul>
                                <li>Glyph coordinates in atlas</li>
                                <li>Drawing offsets</li>
                                <li>Character advance values</li>
                            </ul>
                        </li>
                    </ul>

                    <h4>Technical Implementation</h4>
                    <ul>
                        <li>STB Truetype integration:
                            <ul>
                                <li>Custom memory management hooks</li>
                                <li>Mathematical function mappings</li>
                                <li>Font baking algorithm</li>
                            </ul>
                        </li>
                        
                        <li>UEFI workflow:
                            <ul>
                                <li>Protocol handling (BS, FS, File)</li>
                                <li>Font file location and loading</li>
                                <li>Memory allocation via boot services</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </section>

            <!-- Shell Section -->
            <section id="shell">
                <h2><i class="fas fa-terminal"></i> Shell</h2>
                <div class="section-content">
                    <h3>Shell Process</h3>
                    <p>The system shell provides a command-line interface with:</p>
                    <ul>
                        <li>Command history and recall</li>
                        <li>Tab completion for commands and filenames</li>
                        <li>Input/output redirection</li>
                        <li>Pipeline support for chaining commands</li>
                        <li>Background process execution</li>
                        <li>Scripting capabilities</li>
                    </ul>
                </div>
            </section>

            <div class="footer">
                <p>Custom OS Documentation &copy; 2024 | Hendrik Sorensen</p>
                <p>Last updated: June 2024</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/c.min.js"></script>
    <script>
        // Initialize syntax highlighting
        hljs.highlightAll();
        
        // Handle sidebar navigation
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);
                
                if (targetSection) {
                    // Remove active class from all links
                    document.querySelectorAll('.sidebar a').forEach(a => {
                        a.classList.remove('active');
                    });
                    
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Scroll to section
                    targetSection.scrollIntoView({
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Update active link based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('section');
            let currentSection = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 100) {
                    currentSection = section.getAttribute('id');
                }
            });
            
            document.querySelectorAll('.sidebar a').forEach(a => {
                a.classList.remove('active');
                if (a.getAttribute('href') === `#${currentSection}`) {
                    a.classList.add('active');
                }
            });
        });
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.stdlib-header').forEach(header => {
                // Add collapsed class to header
                header.classList.add('collapsed');
                
                // Add collapsed class to the next sibling (content)
                const content = header.nextElementSibling;
                if (content) {
                    content.classList.add('collapsed');
                }
                
                // Then add the click handler
                header.addEventListener('click', function() {
                    this.classList.toggle('collapsed');
                    if (content) {
                        content.classList.toggle('collapsed');
                    }
                });
            });
        });
    </script>
</body>
</html>